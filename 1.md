---
title: "DoD Blind SQL Injection"
author: "Adria Bonilla Martin"
nick: "k0x"
date: "2024-12-08"
level: "Intermediate"
language: "English"
theme: ["Blind SQLi","BugBounty"]
description: "This blog reveals a SQL Injection vulnerability on a main DoD page, uncovered using enumeration, manual payloads, and SQLMap."
---

This blog explores how a SQL Injection vulnerability was discovered on a key **Department of Defense (DoD)** page. SQL Injection occurs when an application’s input handling allows unintended manipulation of SQL queries, leading to risks such as unauthorized data access or system compromise.

In this case, the issue was identified using blind SQL injection techniques, which extract database information indirectly through response analysis, such as true/false conditions or timing delays.

## **Enumeration**

One of the most challenging aspects (from my perspective) in bug bounty hunting is enumerating assets for programs with a massive scope. I define "massive" as those with multiple large CIDR ranges and/or wildcard domains that return numerous subdomains. Based on my experience, I’ve noticed that using tools like Sublist3r and similar ones often leads to identifying a heavily audited scope where finding critical vulnerabilities becomes significantly difficult.

During the testing period, the following tools were used for enumeration:

1. **[Amass](https://github.com/OWASP/Amass):** A powerful asset discovery tool capable of identifying subdomains, IP blocks, and more.
2. **[Sublist3r](https://github.com/aboul3la/Sublist3r):** A subdomain enumeration tool that aggregates results from various public sources.

While these tools successfully identified numerous assets, most of them lacked critical vulnerabilities such as SQL Injection (SQLi). This is often the case with assets that have been repeatedly scanned and tested by other researchers.

To address this challenge, an effective strategy is to incorporate **Google Dorks** into the enumeration process. Google Dorks allow you to uncover assets that are less commonly identified by automated tools, providing an edge in finding unique vulnerabilities.

For the **DoD program**, this approach is particularly useful. By excluding domains rooted in `.mil` and focusing on other related domains, it becomes possible to refine the search using keywords like:

- "Department of Defense"
- "DoD"

Additionally, many of the pages contain banners and other unique elements that can be extracted as clues for further exploration.

Using **[googler](https://github.com/jarun/googler)**, you can craft a Google Dork to search for **Department of Defense (DoD)** pages that do not contain `.mil` in their domain names. 

For instance, the following Googler command can help in this case:

```bash
googler -- "site:.net 'Department of Defense'"
```

This dork targets pages on `.net`, allowing us to explore alternative assets that could lead to unique findings.

## **Discovery**

## **Key Principles for Vulnerability Discovery**

When discovering vulnerabilities, I always adhere to two key principles:

1. **Critical vulnerabilities are often post-authentication:** Most of the critical issues I’ve uncovered occur after successfully authenticating to the application.  

2. **A semi-manual approach yields better results:** While I use tools like Burp Suite for automation, I complement this with curated payload lists and manually test specific **injection points** that I identify as high-interest during my analysis.  

This method balances the efficiency of automation with the precision of manual testing, significantly increasing the likelihood of finding impactful vulnerabilities.

To identify vulnerabilities in these assets, I used a curated set of payloads specifically for **blind SQL injection**. I often start with these payloads because once a blind SQL injection is identified, I can manually test and experiment with other techniques. 

However, in most cases, I end up fully exploiting the vulnerability through blind SQL injection, as it often proves to be the most reliable and effective method.

For example, I currently use a customized list with slight variations, incorporating other payloads that I’ve found effective during testing. This list is based on the one used by the following tool: [HBSQLI Payloads](https://github.com/SAPT01/HBSQLI/blob/main/payloads.txt).

## **Explotation:**

Fortunately, exploiting this asset was straightforward, even without requiring a cookie. This made it an **unauthenticated vulnerability**, and it was possible to extract data using a simple command with **SQLMap**.

When exploiting vulnerabilities with SQLMap, I always use the `--random-agent` option (which I have set as an alias). This helps avoid detection by Basic Web Application Firewalls (WAFs) by randomizing the User-Agent header in requests.

In future posts, I’ll dive deeper into topics like bypassing restrictions involving cookies and refresh tokens (which often require custom scripts with SQLMap) and techniques for bypassing WAF protections effectively.

## **References:**

- [My Hackerone Profile](https://hackerone.com/k0x)
- [SQL Injection Report](https://hackerone.com/reports/2737595)

To embed a Twitter article in your markdown content, you can use the `TwitterTweetEmbed` component from the `react-twitter-embed` library. Here's how you can set it up:

1. **Install the `react-twitter-embed` library**:
   Run the following command to install the `react-twitter-embed` library:

   ```bash
   npm install react-twitter-embed
   ```

2. **Update your `PostPage` component**:
   Import the `TwitterTweetEmbed` component and add it to the `markdown-to-jsx` options to allow embedding tweets in your markdown content.

Here's the updated code for your `PostPage` component:

```javascript


import React, { useState, useEffect, useCallback } from "react";
import { useParams } from "react-router-dom";
import matter from "gray-matter";
import Markdown from "markdown-to-jsx";
import Container from "@mui/material/Container";
import Grid from "@mui/material/Grid";
import Card from "@mui/material/Card";
import CircularProgress from "@mui/material/CircularProgress";
import Alert from "@mui/material/Alert";
import Snackbar from "@mui/material/Snackbar";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import { materialDark } from "react-syntax-highlighter/dist/esm/styles/prism";
import MKBox from "components/MKBox";
import MKTypography from "components/MKTypography";
import DefaultNavbar from "custom/Navbars/DefaultNavbar";
import DefaultFooter from "custom/Footers/DefaultFooter";
import routes from "routes";
import footerRoutes from "footer.routes";
import bgImage from "assets/images/brand_sm.png";
import IconButton from "@mui/material/IconButton";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";
import { TwitterTweetEmbed } from 'react-twitter-embed';

// Function to fetch the post content from GitHub
const fetchPost = async (postId, setPost, setError) => {
  try {
    const repoOwner = "pwncat-offsec";
    const repoName = "Blog";
    const apiUrl = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${postId}.md`;

    const response = await fetch(apiUrl);
    if (!response.ok) {
      throw new Error(`GitHub API request failed: ${response.statusText}`);
    }

    const file = await response.json();
    const markdownWithMeta = Buffer.from(file.content, 'base64').toString('utf-8');
    const { data: frontMatter, content } = matter(markdownWithMeta);

    setPost({ frontMatter, content });
  } catch (error) {
    console.error("Failed to load post:", error);
    setError(true);
  }
};

const CopyCodeButton = ({ code, onCopy }) => {
  const handleCopy = () => {
    navigator.clipboard.writeText(code);
    onCopy();
  };

  return (
    <IconButton
      onClick={handleCopy}
      sx={{
        position: "absolute",
        top: "0.5rem",
        right: "0.5rem",
        color: "white",
        width: "24px",
        height: "24px",
        "&:hover": {
          backgroundColor: "rgba(255, 255, 255, 0.4)",
        },
        zIndex: 2, // Ensure the button is on top
        borderRadius: "4px", // Make the button square
      }}
    >
      <ContentCopyIcon color="white" sx={{ fontSize: "16px" }} />
    </IconButton>
  );
};

const PostPage = () => {
  const { postId } = useParams();
  const [post, setPost] = useState(null);
  const [error, setError] = useState(false);
  const [snackbarOpen, setSnackbarOpen] = useState(false);

  const fetchPostCallback = useCallback(() => {
    fetchPost(postId, setPost, setError);
  }, [postId]);

  useEffect(() => {
    fetchPostCallback();
  }, [fetchPostCallback]);

  const handleSnackbarClose = () => {
    setSnackbarOpen(false);
  };

  const handleCopy = () => {
    setSnackbarOpen(true);
  };

  if (error) {
    return (
      <Container>
        <Alert severity="error">Failed to load post. Please try again later.</Alert>
      </Container>
    );
  }

  if (!post) {
    return (
      <Container>
        <CircularProgress />
      </Container>
    );
  }

  return (
    <>
      <DefaultNavbar
        routes={routes}
        action={{
          type: "external",
          route: "/support/contact-us",
          label: "Get Started",
          color: "info",
        }}
        transparent
        light
      />
      <MKBox
        minHeight="40vh"
        width="100%"
        sx={{
          backgroundImage: `url(${bgImage})`,
          backgroundSize: "cover",
          backgroundPosition: "center",
          display: "grid",
          placeItems: "center",
        }}
      >
        <Container>
          <Grid
            container
            item
            xs={12}
            lg={8}
            justifyContent="center"
            sx={{ mx: "auto", textAlign: "center" }}
          >
            <MKTypography variant="h3" color="white">
              {post.frontMatter.title}
            </MKTypography>
            <MKTypography variant="body1" color="white" mt={1}>
              {post.frontMatter.description}
            </MKTypography>
          </Grid>
        </Container>
      </MKBox>
      <Card sx={{ p: 2, mx: { xs: 2, lg: 3 }, mt: -8, mb: 4 }}>
        <MKBox component="section">
          <Container>
            <Grid container spacing={3} sx={{ mt: 3 }}>
              <Grid item xs={12}>
                <MKTypography variant="body2" color="text" mt={1}>
                  {post.frontMatter.date} - {post.frontMatter.author} ({post.frontMatter.nick})
                </MKTypography>
                <MKBox mt={3}>
                  <Markdown
                    options={{
                      overrides: {
                        h1: {
                          component: MKTypography,
                          props: {
                            variant: "h4",
                            gutterBottom: true,
                            style: { marginTop: "2rem", marginBottom: "1rem", textAlign: "justify" },
                          },
                        },
                        h2: {
                          component: MKTypography,
                          props: {
                            variant: "h5",
                            gutterBottom: true,
                            style: { marginTop: "1.75rem", marginBottom: "1rem", textAlign: "justify" },
                          },
                        },
                        h3: {
                          component: MKTypography,
                          props: {
                            variant: "h6",
                            gutterBottom: true,
                            style: { marginTop: "1.5rem", marginBottom: "1rem", textAlign: "justify" },
                          },
                        },
                        p: {
                          component: MKTypography,
                          props: {
                            variant: "body2",
                            paragraph: true,
                            sx: { textAlign: "justify" },
                            style: { marginTop: "1rem", marginBottom: "1rem" },
                          },
                        },
                        a: {
                          component: MKTypography,
                          props: {
                            variant: "body2",
                            color: "primary",
                            sx: {
                              textDecoration: "underline",
                              fontWeight: "bold",
                              cursor: "pointer",
                              display: "inline",
                              textAlign: "justify",
                            },
                          },
                        },
                        strong: {
                          component: MKTypography,
                          props: {
                            variant: "body2",
                            component: "span",
                            sx: { fontWeight: "bold", display: "inline", textAlign: "justify" },
                          },
                        },
                        span: {
                          component: MKTypography,
                          props: {
                            variant: "body2",
                            component: "span",
                          },
                        },
                        li: {
                          component: (props) => (
                            <li style={{ fontSize: "1rem", fontWeight: "bold", display: "list-item", marginBottom: "1em", textAlign: "justify" }}>
                              <span style={{ display: "inline" }}>
                                <MKTypography variant="body2" component="span" display="block" {...props} />
                              </span>
                            </li>
                          ),
                        },
                        ul: {
                          component: (props) => (
                            <ul style={{ paddingLeft: "1.5rem", fontSize: "1rem", listStyleType: "disc", listStylePosition: "outside", marginTop: "1em", marginBottom: "1em", marginLeft: "3em",paddingLeft: 0, textAlign: "justify" }} {...props} />
                          ),
                        },
                        ol: {
                          component: (props) => (
                            <ol style={{ paddingLeft: "1.5rem", fontSize: "1rem", listStyleType: "decimal", listStylePosition: "outside", marginTop: "1em", marginBottom: "1em", marginLeft: "3em", paddingLeft: 0, textAlign: "justify" }} {...props} />
                          ),
                        },
                        code: {
                          component: ({ className, children }) => {
                            const language = className?.replace("lang-", "") || "";
                            const code = children.trim();
                            if (language) {
                              return (
                                <MKBox sx={{ position: "relative", my: 2 }}>
                                  <SyntaxHighlighter
                                    style={materialDark}
                                    language={language}
                                    customStyle={{ maxWidth: "100%", margin: "0 auto", padding: "1em", borderRadius: "4px", fontSize: "0.875rem" }}
                                  >
                                    {code}
                                  </SyntaxHighlighter>
                                </MKBox>
                              );
                            } else {
                              return (
                                <MKTypography
                                  component="code"
                                  variant="body2"
                                  sx={{ backgroundColor: "#f5f5f5", padding: "2px 4px", borderRadius: "4px", fontSize: "0.85em" }}
                                >
                                  {children}
                                </MKTypography>
                              );
                            }
                          },
                        },
                        pre: {
                          component: ({ children }) => {
                            const code = children.props.children.trim();
                            return (
                              <MKBox sx={{ position: "relative", mt: 2, mb: 2, backgroundColor: "rgb(47, 47, 47)"}}>
                                <CopyCodeButton code={code} onCopy={handleCopy} />
                                <pre style={{ position: "relative", padding: "0px", borderRadius: "4px", overflowX: "auto" }}>
                                  <div className="MuiBox-root css-1rd7817">
                                    <pre style={{ textAlign: "left", whiteSpace: "pre", wordSpacing: "normal", wordBreak: "normal", overflowWrap: "normal", color: "rgb(238, 238, 238)", background: "rgb(47, 47, 47)", fontFamily: "'Roboto Mono', monospace", fontSize: "0.875rem", lineHeight: "1.5em", tabSize: "4", hyphens: "none", overflow: "auto", position: "relative", margin: "0px auto", padding: "1em 1em", maxWidth: "100%", borderRadius: "4px" }}>
                                      {children.props.children}
                                    </pre>
                                  </div>
                                </pre>
                              </MKBox>
                            );
                          },
                        },
                        TwitterTweet: {
                          component: ({ tweetId }) => (
                            <TwitterTweetEmbed tweetId={tweetId} />
                          ),
                        },
                      },
                    }}
                  >
                    {post.content}
                  </Markdown>
                </MKBox>
              </Grid>
            </Grid>
          </Container>
        </MKBox>
      </Card>
      <MKBox pt={6} px={1} mt={6}>
        <DefaultFooter content={footerRoutes} />
      </MKBox>
      <Snackbar
        open={snackbarOpen}
        autoHideDuration={4000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'top', horizontal: 'center' }}
      >
        <Alert onClose={handleSnackbarClose} severity="success" sx={{ width: '100%' }}>
          Copied to clipboard
        </Alert>
      </Snackbar>
    </>
  );
};

export default React.memo(PostPage);
```

### Usage in Markdown:

To embed a tweet in your markdown content, you can use the following syntax:

```markdown
<TwitterTweet tweetId="1870208692710478232" />
```

Here is how your markdown file should look:

```markdown
---
title: "DoD Blind SQL Injection"
author: "Adria Bonilla Martin"
nick: "k0x"
date: "2024-12-08"
level: "Intermediate"
language: "English"
theme: ["Blind SQLi","BugBounty"]
description: "This blog reveals a SQL Injection vulnerability on a main DoD page, uncovered using enumeration, manual payloads, and SQLMap."
---

This blog explores how a SQL Injection vulnerability was discovered on a key **Department of Defense (DoD)** page. SQL Injection occurs when an application’s input handling allows unintended manipulation of SQL queries, leading to risks such as unauthorized data access or system compromise.

In this case, the issue was identified using blind SQL injection techniques, which extract database information indirectly through response analysis, such as true/false conditions or timing delays.

## **Enumeration**

One of the most challenging aspects (from my perspective) in bug bounty hunting is enumerating assets for programs with a massive scope. I define "massive" as those with multiple large CIDR ranges and/or wildcard domains that return numerous subdomains. Based on my experience, I’ve noticed that using tools like Sublist3r and similar ones often leads to identifying a heavily audited scope where finding critical vulnerabilities becomes significantly difficult.

During the testing period, the following tools were used for enumeration:

1. **[Amass](https://github.com/OWASP/Amass):** A powerful asset discovery tool capable of identifying subdomains, IP blocks, and more.
2. **[Sublist3r](https://github.com/aboul3la/Sublist3r):** A subdomain enumeration tool that aggregates results from various public sources.

While these tools successfully identified numerous assets, most of them lacked critical vulnerabilities such as SQL Injection (SQLi). This is often the case with assets that have been repeatedly scanned and tested by other researchers.

To address this challenge, an effective strategy is to incorporate **Google Dorks** into the enumeration process. Google Dorks allow you to uncover assets that are less commonly identified by automated tools, providing an edge in finding unique vulnerabilities.

For the **DoD program**, this approach is particularly useful. By excluding domains rooted in `.mil` and focusing on other related domains, it becomes possible to refine the search using keywords like:

- "Department of Defense"
- "DoD"

Additionally, many of the pages contain banners and other unique elements that can be extracted as clues for further exploration.

Using **[googler](https://github.com/jarun/googler)**, you can craft a Google Dork to search for **Department of Defense (DoD)** pages that do not contain `.mil` in their domain names. 

For instance, the following Googler command can help in this case:

```bash
googler -- "site:.net 'Department of Defense'"
```

This dork targets pages on `.net`, allowing us to explore alternative assets that could lead to unique findings.

## **Discovery**

## **Key Principles for Vulnerability Discovery**

When discovering vulnerabilities, I always adhere to two key principles:

1. **Critical vulnerabilities are often post-authentication:** Most of the critical issues I’ve uncovered occur after successfully authenticating to the application.  

2. **A semi-manual approach yields better results:** While I use tools like Burp Suite for automation, I complement this with curated payload lists and manually test specific **injection points** that I identify as high-interest during my analysis.  

This method balances the efficiency of automation with the precision of manual testing, significantly increasing the likelihood of finding impactful vulnerabilities.

To identify vulnerabilities in these assets, I used a curated set of payloads specifically for **blind SQL injection**. I often start with these payloads because once a blind SQL injection is identified, I can manually test and experiment with other techniques. 

However, in most cases, I end up fully exploiting the vulnerability through blind SQL injection, as it often proves to be the most reliable and effective method.

For example, I currently use a customized list with slight variations, incorporating other payloads that I’ve found effective during testing. This list is based on the one used by the following tool: [HBSQLI Payloads](https://github.com/SAPT01/HBSQLI/blob/main/payloads.txt).

## **Explotation:**

Fortunately, exploiting this asset was straightforward, even without requiring a cookie. This made it an **unauthenticated vulnerability**, and it was possible to extract data using a simple command with **SQLMap**.

When exploiting vulnerabilities with SQLMap, I always use the `--random-agent` option (which I have set as an alias). This helps avoid detection by Basic Web Application Firewalls (WAFs) by randomizing the User-Agent header in requests.

In future posts, I’ll dive deeper into topics like bypassing restrictions involving cookies and refresh tokens (which often require custom scripts with SQLMap) and techniques for bypassing WAF protections effectively.

## **References:**

- [My Hackerone Profile](https://hackerone.com/k0x)
- [SQL Injection Report](https://hackerone.com/reports/2737595)

<TwitterTweet tweetId="1870208692710478232" />
